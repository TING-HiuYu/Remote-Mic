use std::{env, fs, path::Path};

// Build script that embeds all JSON files under ./lang into a generated Rust source file.
// This lets the application load localization data without any runtime filesystem access.
fn main() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let lang_dir = Path::new("lang");

    // ---- Windows linking fix ----
    // Some transitive dependencies (e.g. crates pulling in Windows security / crypto APIs)
    // may fail to link on GitHub Actions Windows runners with unresolved externals like
    // `__imp_OpenProcessToken`, `__imp_CheckTokenMembership`, etc. These symbols live in
    // advapi32 (and sometimes secur32 / crypt32). Emitting explicit link directives here
    // ensures the final binary links cleanly even if upstream crates omit them in certain
    // feature combinations.
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-link-lib=advapi32");
        println!("cargo:rustc-link-lib=secur32");
        println!("cargo:rustc-link-lib=crypt32");
        // (Optional) Uncomment if further ws2_32/userenv symbols show up:
        // println!("cargo:rustc-link-lib=ws2_32");
        // println!("cargo:rustc-link-lib=userenv");
    }

    // Trigger rebuild when directory or any json file changes.
    println!("cargo:rerun-if-changed=lang");

    let mut entries: Vec<String> = Vec::new();
    if let Ok(read_dir) = fs::read_dir(lang_dir) {
        for entry in read_dir.flatten() {
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                    let content = fs::read_to_string(&path)
                        .unwrap_or_else(|e| panic!("failed to read {:?}: {e}", path));
                    // Use raw string literal to preserve JSON exactly. Choose a delimiter unlikely to collide.
                    // If the JSON ever contains `#####` adjust the delimiter.
                    entries.push(format!("(\"{stem}\", r#####\"{content}\"#####)"));
                }
            }
        }
    }

    // Sort for deterministic build output.
    entries.sort();

    let generated = format!(
        "// AUTO-GENERATED BY build.rs - DO NOT EDIT\n\n#[allow(clippy::unreadable_literal)]\npub static EMBEDDED_LANGS: &[(&str, &str)] = &[\n{}\n];\n",
        entries.join(",\n")
    );

    fs::write(Path::new(&out_dir).join("lang_data.rs"), generated)
        .expect("failed to write generated lang_data.rs");
}
